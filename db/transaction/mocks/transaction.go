// Automatically generated by MockGen. DO NOT EDIT!
// Source: transaction.go

package mocks

import (
	pagination "github.com/cloudwan/gohan/db/pagination"
	"github.com/cloudwan/gohan/db/transaction"
	schema "github.com/cloudwan/gohan/schema"
	gomock "github.com/golang/mock/gomock"
	sqlx "github.com/jmoiron/sqlx"
)

// Mock of Transaction interface
type MockTransaction struct {
	ctrl     *gomock.Controller
	recorder *_MockTransactionRecorder
}

// Recorder for MockTransaction (not exported)
type _MockTransactionRecorder struct {
	mock *MockTransaction
}

func NewMockTransaction(ctrl *gomock.Controller) *MockTransaction {
	mock := &MockTransaction{ctrl: ctrl}
	mock.recorder = &_MockTransactionRecorder{mock}
	return mock
}

func (_m *MockTransaction) EXPECT() *_MockTransactionRecorder {
	return _m.recorder
}

func (_m *MockTransaction) Create(_param0 *schema.Resource) error {
	ret := _m.ctrl.Call(_m, "Create", _param0)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockTransactionRecorder) Create(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Create", arg0)
}

func (_m *MockTransaction) Update(_param0 *schema.Resource) error {
	ret := _m.ctrl.Call(_m, "Update", _param0)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockTransactionRecorder) Update(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Update", arg0)
}

func (_m *MockTransaction) StateUpdate(_param0 *schema.Resource, _param1 *transaction.ResourceState) error {
	ret := _m.ctrl.Call(_m, "StateUpdate", _param0, _param1)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockTransactionRecorder) StateUpdate(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "StateUpdate", arg0, arg1)
}

func (_m *MockTransaction) Delete(_param0 *schema.Schema, _param1 interface{}) error {
	ret := _m.ctrl.Call(_m, "Delete", _param0, _param1)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockTransactionRecorder) Delete(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Delete", arg0, arg1)
}

func (_m *MockTransaction) Fetch(_param0 *schema.Schema, _param1 transaction.Filter, _param2 *transaction.ViewOptions) (*schema.Resource, error) {
	ret := _m.ctrl.Call(_m, "Fetch", _param0, _param1, nil)
	ret0, _ := ret[0].(*schema.Resource)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockTransactionRecorder) Fetch(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Fetch", arg0, arg1)
}

func (_m *MockTransaction) LockFetch(_param0 *schema.Schema, _param1 transaction.Filter, _param2 schema.LockPolicy, _param3 *transaction.ViewOptions) (*schema.Resource, error) {
	ret := _m.ctrl.Call(_m, "LockFetch", _param0, _param1, _param2, _param3)
	ret0, _ := ret[0].(*schema.Resource)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockTransactionRecorder) LockFetch(arg0, arg1, arg2 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "LockFetch", arg0, arg1, arg2)
}

func (_m *MockTransaction) StateFetch(_param0 *schema.Schema, _param1 transaction.Filter) (transaction.ResourceState, error) {
	ret := _m.ctrl.Call(_m, "StateFetch", _param0, _param1)
	ret0, _ := ret[0].(transaction.ResourceState)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockTransactionRecorder) StateFetch(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "StateFetch", arg0, arg1)
}

func (_m *MockTransaction) List(_param0 *schema.Schema, _param1 transaction.Filter, _param2 *transaction.ViewOptions, _param3 *pagination.Paginator) ([]*schema.Resource, uint64, error) {
	ret := _m.ctrl.Call(_m, "List", _param0, _param1, _param2, _param3)
	ret0, _ := ret[0].([]*schema.Resource)
	ret1, _ := ret[1].(uint64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

func (_mr *_MockTransactionRecorder) List(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "List", arg0, arg1, arg2, arg3)
}

func (_m *MockTransaction) LockList(_param0 *schema.Schema, _param1 transaction.Filter, _param2 *transaction.ViewOptions, _param3 *pagination.Paginator, _param4 schema.LockPolicy) ([]*schema.Resource, uint64, error) {
	ret := _m.ctrl.Call(_m, "LockList", _param0, _param1, _param2, _param3, _param4)
	ret0, _ := ret[0].([]*schema.Resource)
	ret1, _ := ret[1].(uint64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

func (_mr *_MockTransactionRecorder) LockList(arg0, arg1, arg2, arg3, arg4 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "LockList", arg0, arg1, arg2, arg3, arg4)
}

func (_m *MockTransaction) RawTransaction() *sqlx.Tx {
	ret := _m.ctrl.Call(_m, "RawTransaction")
	ret0, _ := ret[0].(*sqlx.Tx)
	return ret0
}

func (_mr *_MockTransactionRecorder) RawTransaction() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "RawTransaction")
}

func (_m *MockTransaction) Query(_param0 *schema.Schema, _param1 string, _param2 []interface{}) ([]*schema.Resource, error) {
	ret := _m.ctrl.Call(_m, "Query", _param0, _param1, _param2)
	ret0, _ := ret[0].([]*schema.Resource)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockTransactionRecorder) Query(arg0, arg1, arg2 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Query", arg0, arg1, arg2)
}

func (_m *MockTransaction) Commit() error {
	ret := _m.ctrl.Call(_m, "Commit")
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockTransactionRecorder) Commit() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Commit")
}

func (_m *MockTransaction) Exec(query string, args ...interface{}) error {
	_s := []interface{}{query}
	for _, _x := range args {
		_s = append(_s, _x)
	}
	ret := _m.ctrl.Call(_m, "Exec", _s...)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockTransactionRecorder) Exec(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	_s := append([]interface{}{arg0}, arg1...)
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Exec", _s...)
}

func (_m *MockTransaction) Close() error {
	ret := _m.ctrl.Call(_m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockTransactionRecorder) Close() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Close")
}

func (_m *MockTransaction) Closed() bool {
	ret := _m.ctrl.Call(_m, "Closed")
	ret0, _ := ret[0].(bool)
	return ret0
}

func (_mr *_MockTransactionRecorder) Closed() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Closed")
}

func (_m *MockTransaction) GetIsolationLevel() transaction.Type {
	ret := _m.ctrl.Call(_m, "GetIsolationLevel")
	ret0, _ := ret[0].(transaction.Type)
	return ret0
}

func (_mr *_MockTransactionRecorder) GetIsolationLevel() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "GetIsolationLevel")
}
